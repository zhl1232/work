-- Add completion_comments table
CREATE TABLE IF NOT EXISTS public.completion_comments (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    completed_project_id BIGINT NOT NULL REFERENCES public.completed_projects(id) ON DELETE CASCADE,
    author_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Add completion_likes table
CREATE TABLE IF NOT EXISTS public.completion_likes (
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    completed_project_id BIGINT NOT NULL REFERENCES public.completed_projects(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    PRIMARY KEY (user_id, completed_project_id)
);

-- RLS for completion_comments
ALTER TABLE public.completion_comments ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Anyone can view completion comments" ON public.completion_comments;
CREATE POLICY "Anyone can view completion comments"
    ON public.completion_comments FOR SELECT
    USING (true);

DROP POLICY IF EXISTS "Authenticated users can create completion comments" ON public.completion_comments;
CREATE POLICY "Authenticated users can create completion comments"
    ON public.completion_comments FOR INSERT
    WITH CHECK (auth.uid() = author_id);

DROP POLICY IF EXISTS "Users can delete their own completion comments" ON public.completion_comments;
CREATE POLICY "Users can delete their own completion comments"
    ON public.completion_comments FOR DELETE
    USING (auth.uid() = author_id);

-- RLS for completion_likes
ALTER TABLE public.completion_likes ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Anyone can view completion likes" ON public.completion_likes;
CREATE POLICY "Anyone can view completion likes"
    ON public.completion_likes FOR SELECT
    USING (true);

DROP POLICY IF EXISTS "Authenticated users can like completions" ON public.completion_likes;
CREATE POLICY "Authenticated users can like completions"
    ON public.completion_likes FOR INSERT
    WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Authenticated users can unlike completions" ON public.completion_likes;
CREATE POLICY "Authenticated users can unlike completions"
    ON public.completion_likes FOR DELETE
    USING (auth.uid() = user_id);

-- Function to increment likes_count on completed_projects AND award XP to author
CREATE OR REPLACE FUNCTION public.handle_new_completion_like()
RETURNS TRIGGER AS $$
DECLARE
    v_author_id UUID;
BEGIN
    -- 1. Update likes_count and retrieve the author of the work
    UPDATE public.completed_projects
    SET likes_count = likes_count + 1
    WHERE id = NEW.completed_project_id
    RETURNING user_id INTO v_author_id;

    -- 2. Award 1 XP to the author
    IF v_author_id IS NOT NULL THEN
        UPDATE public.profiles
        SET 
            xp = xp + 1,
            level = floor(sqrt((xp + 1) / 100)) + 1
        WHERE id = v_author_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to decrement likes_count AND deduct XP (Anti-cheat)
CREATE OR REPLACE FUNCTION public.handle_remove_completion_like()
RETURNS TRIGGER AS $$
DECLARE
    v_author_id UUID;
BEGIN
    -- 1. Update likes_count and retrieve the author of the work
    UPDATE public.completed_projects
    SET likes_count = likes_count - 1
    WHERE id = OLD.completed_project_id
    RETURNING user_id INTO v_author_id;

    -- 2. Deduct 1 XP from the author (prevent negative XP if desired, but here we allow symmetry)
    IF v_author_id IS NOT NULL THEN
        UPDATE public.profiles
        SET 
            xp = GREATEST(0, xp - 1),
            level = floor(sqrt(GREATEST(0, xp - 1) / 100)) + 1
        WHERE id = v_author_id;
    END IF;

    RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to award XP on new completion comment (Danmaku) - Anti-cheat enforced
CREATE OR REPLACE FUNCTION public.handle_new_completion_comment()
RETURNS TRIGGER AS $$
DECLARE
    v_author_id UUID;
    v_comment_count INT;
BEGIN
    -- 1. Get the author of the completed project
    SELECT user_id INTO v_author_id
    FROM public.completed_projects
    WHERE id = NEW.completed_project_id;

    -- 2. Check how many comments THIS user have on THIS project
    -- Since this trigger fires AFTER INSERT, count should be at least 1 (the current one)
    SELECT COUNT(*) INTO v_comment_count
    FROM public.completion_comments
    WHERE completed_project_id = NEW.completed_project_id
    AND author_id = NEW.author_id;

    -- 3. Only award XP if this is the FIRST comment by this user on this project
    -- However, because of concurrency, it's safer to say: if count == 1
    IF v_author_id IS NOT NULL AND v_comment_count = 1 THEN
        UPDATE public.profiles
        SET 
            xp = xp + 1,
            level = floor(sqrt((xp + 1) / 100)) + 1
        WHERE id = v_author_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to deduct XP on completion comment deletion - Anti-cheat enforced
CREATE OR REPLACE FUNCTION public.handle_remove_completion_comment()
RETURNS TRIGGER AS $$
DECLARE
    v_author_id UUID;
    v_comment_count INT;
BEGIN
    -- 1. Get the author of the completed project
    SELECT user_id INTO v_author_id
    FROM public.completed_projects
    WHERE id = OLD.completed_project_id;

    -- 2. Check existing comments by this user on this project
    -- Since this trigger fires AFTER DELETE, we check if any comments remain.
    SELECT COUNT(*) INTO v_comment_count
    FROM public.completion_comments
    WHERE completed_project_id = OLD.completed_project_id
    AND author_id = OLD.author_id;

    -- 3. Only deduct XP if the user has NO comments left (meaning they deleted their last/only comment)
    IF v_author_id IS NOT NULL AND v_comment_count = 0 THEN
        UPDATE public.profiles
        SET 
            xp = GREATEST(0, xp - 1),
            level = floor(sqrt(GREATEST(0, xp - 1) / 100)) + 1
        WHERE id = v_author_id;
    END IF;

    RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Triggers

DROP TRIGGER IF EXISTS on_completion_like_added ON public.completion_likes;
CREATE TRIGGER on_completion_like_added
    AFTER INSERT ON public.completion_likes
    FOR EACH ROW EXECUTE PROCEDURE public.handle_new_completion_like();

DROP TRIGGER IF EXISTS on_completion_like_removed ON public.completion_likes;
CREATE TRIGGER on_completion_like_removed
    AFTER DELETE ON public.completion_likes
    FOR EACH ROW EXECUTE PROCEDURE public.handle_remove_completion_like();

DROP TRIGGER IF EXISTS on_completion_comment_added ON public.completion_comments;
CREATE TRIGGER on_completion_comment_added
    AFTER INSERT ON public.completion_comments
    FOR EACH ROW EXECUTE PROCEDURE public.handle_new_completion_comment();

DROP TRIGGER IF EXISTS on_completion_comment_removed ON public.completion_comments;
CREATE TRIGGER on_completion_comment_removed
    AFTER DELETE ON public.completion_comments
    FOR EACH ROW EXECUTE PROCEDURE public.handle_remove_completion_comment();
